25.7.16

亿百特 蓝牙模块

伦茨 蓝牙芯片 ST17H62 QFN-32
只能做Mesh参加者  GATT GAP

上海一家 蓝牙芯片

泰凌微电子 主控
开发板有三块，带两个Dongle 

Mesh 不是星型网络，每一个都可以做发起者

蓝牙音箱主控是 ESP32，这个不追求低功耗

###### ==什么是蓝牙Dongle？==
蓝牙 Dongle = **把“没有蓝牙”的电脑/设备，变成“有蓝牙”的小外挂**。  
本质就是一颗 **USB（或 UART/SPI）→ 蓝牙双模芯片** 的极简成品，插上即装驱动，立刻能配对键盘、耳机、手柄、BLE 传感器等。

──────────────────  
1. 外观 & 接口  
• **USB-A** 最常见：像 5 毛硬币大的小 U 盘。  
• USB-C、Micro-USB、甚至 Lightning 也有，给手机/平板用。  
• 有的做成 **UART/SPI 模块**，直接焊在主板上，叫“嵌入式 Dongle”。

2. 里头有什么 

| 部分      | 作用                     | 常见芯片                                        |
| ------- | ---------------------- | ------------------------------------------- |
| 射频 SoC  | 蓝牙 4.2/5.0/5.3         | RTL8761、BCM20702、CYW43455、ESP32-S3、nRF52840 |
| 天线      | 板载陶瓷/PCB 天线或 IPEX      | 已调匹配                                        |
| 稳压 & 晶振 | 5 V→3.3 V、26 MHz       | 一体封装                                        |
| USB 桥   | 免驱 HID/CDC 或厂商 VID/PID | 固件已烧好                                       |

3. 典型用途  
• **台式机**没蓝牙 → 插 USB Dongle → 连蓝牙耳机/鼠标。  
• **树莓派/单片机**通过 UART Dongle → 让老 STM32 直接跑 BLE 透传。  
• **产线测试** → 量产 Dongle 插 PC，自动给成品做蓝牙 RF 校准或功能测试。

4. 一句话记忆  
“Dongle 就是**把蓝牙射频+协议栈+天线打包成即插即用的‘小尾巴’**。”

###### ==什么是闭源库，如何判断闭源库==

头文件.h告诉编译器有哪些函数、结构体和宏可以使用。库文件（`.a/.so/.lib` 或 `.c/.cpp`）实现函数的真正实现。

| 文件    | 生成命令          | 链接阶段           | 文件大小        | 运行时依赖       |
| ----- | ------------- | -------------- | ----------- | ----------- |
| `.o`  | `gcc -c`      | 不参与            | 最小          | 无           |
| `.a`  | `ar rcs`      | 静态链接时**整体复制**  | ≈所有 `.o` 之和 | 无           |
| `.so` | `gcc -shared` | 动态链接时**仅登记符号** | 较大          | 需要 `.so` 存在 |

| 维度    | `.a` (static archive)         | `.so` (shared object)                        |
| ----- | ----------------------------- | -------------------------------------------- |
| 链接时机  | 编译阶段（静态链接）                    | 运行阶段（动态链接）                                   |
| 文件大小  | 大（代码被复制进最终 ELF）               | 小（仅符号表）                                      |
| 运行时依赖 | 无，可执行文件里自带                    | 必须有对应 `.so` 存在                               |
| 内存占用  | 每个进程一份                        | 系统一次加载，多个进程共享                                |
| 更新升级  | 必须重新编译可执行文件                   | 直接替换 `.so` 即可                                |
| 典型扩展名 | Linux/macOS `.a`              | Linux/macOS `.so`                            |
| 生成命令  | `ar rcs libfoo.a foo.o bar.o` | `gcc -shared -fPIC -o libfoo.so foo.o bar.o` |
**在被编译后，.a里的所有.o文件就都被放在了生成的最终可执行文件里**  

**.so则不会把代码复制到可执行文件，而是留下一个==符号表==，操作系统根据符号表去磁盘把对应的 `.so` 加载到内存，并把函数地址填进来。**

1. 闭源库：指的是库函数的源码不可见  
    头文件里只给出函数原型，实际实现放在 `.a` / `.so` / `.lib` 里，你**只能链接，无法查看和修改源码**。
    `.a` / `.so` / `.lib`都属于已经编译好的二进制文件

| 扩展名    | 全称 / 类型                      | 平台                        | 何时被链接     | 说明                                                                      |
| ------ | ---------------------------- | ------------------------- | --------- | ----------------------------------------------------------------------- |
| `.a`   | **static archive**（静态库）      | Linux / macOS / BSD / 嵌入式 | **编译阶段**  | 链接器把整个 `.a` 复制到最终可执行文件里，生成体积大，但无运行时依赖。                                  |
| `.so`  | **shared object**（共享库 / 动态库） | Linux / Android / BSD     | **运行阶段**  | 可执行文件启动时才加载，体积最小，可多个程序共享同一份 `.so`。                                      |
| `.lib` | **library**（静态或导入库）          | Windows                   | 编译阶段或运行阶段 | Windows 下 `.lib` 有两种：<br>1. 静态库（同 Linux `.a`）<br>2. 导入库（对应 `.dll` 的符号表） |

2. 如何判断一个库是不是闭源库

| 现象                                             | 结论            |
| ---------------------------------------------- | ------------- |
| 只有 `xxx.h` + `libxxx.a` / `xxx.lib` / `xxx.so` | 闭源静态库或动态库     |
| 同时存在 `xxx.c` / `xxx.cpp`                       | 开源（至少这部分源码可见） |
| 头文件里函数声明带 `extern "C"` 但无实现                    | 实现藏在库文件里      |
| 头文件里根本没有某些函数声明，但文档提到可用                         | 符号被隐藏或需要额外私有包 |
闭源库在哪：SDK下：

| 目录名                            | 出现场合           | 说明                                    |
| ------------------------------ | -------------- | ------------------------------------- |
| `lib`                          | 最常见            | 静态库 `.a`、动态库 `.so`、导入库 `.lib` 基本都放这里。 |
| `library` / `libraries`        | 某些国产或 RTOS SDK | 与 `lib` 同义，只是名字更直白。                   |
| `lib/release`、`lib/debug`      | Keil/IAR 工程    | 区分 Release/Debug 版本的库。                |
| `build/lib`、`output/lib`       | 自编译 SDK        | 先编译源码再生成库时，成品会落到这里。                   |
| `third_party/lib`、`vendor/lib` | 含第三方闭源 IP      | 一眼就能看出是“外部给的”。                        |
| `components/xxx/lib`           | 组件化 SDK        | 每个组件自带私有库。                            |
开源库：

| 目录名                            | 典型内容                        | 备注                           |
| ------------------------------ | --------------------------- | ---------------------------- |
| `src` / `source`               | `.c` `.cpp` `.S` 源文件        | 最常见                          |
| `drivers` / `hal`              | 芯片外设驱动源码                    | 全开源或部分开源                     |
| `components` / `middleware`    | 协议栈、文件系统、USB 等              | 如果里面有 `.c` 就是源码开放            |
| `os` / `rtos`                  | FreeRTOS、Zephyr、RT-Thread 等 | 开源 RTOS 源码                   |
| `examples`                     | 示例应用源码                      | 参考代码，开放                      |
| `external` / `third_party/src` | 外部开源库源码                     | 如 `cJSON`, `lwip`, `mbedtls` |




